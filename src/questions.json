[
  {
    "examName": "Ex-Jun-23",
    "questions": [
      {
        "text": "Marca cuál de las siguientes afirmaciones es cierta:",
        "options": [
          { "id": 0, "text": "En comunicación indirecta existe un desacoplamiento en espacio y tiempo entre los participantes.", "isCorrect": true },
          { "id": 1, "text": "Implementar comunicación indirecta es apropiado para la difusión de eventos, pero cuando los receptores son bien conocidos y no suelen cambiar.", "isCorrect": false },
          { "id": 2, "text": "En comunicación indirecta se utiliza un intermediario y todas las partes de la comunicación deben estar en ejecución.", "isCorrect": false },
          { "id": 3, "text": "RMI implementa comunicación indirecta.", "isCorrect": false }
        ]
      },
      {
        "text": "¿Cuál es el modelo de comunicación más adecuado para un sistema de estaciones meteorológicas que informan sobre  [2p] ¿Cuál es el modelo de comunicación más adecuado para un sistema de estaciones meteorológicas que informan sobre temperatura, viento y presión a un conjunto indeterminado y dinámico de posibles clientes?",
        "options": [
          { "id": 0, "text": "Polling a una base de datos.", "isCorrect": false },
          { "id": 1, "text": "Un sistema publicador-subscriptor", "isCorrect": true },
          { "id": 2, "text": "Un sistema de ficheros distribuido.", "isCorrect": true },
          { "id": 3, "text": "RPC o RMI.", "isCorrect": false }
        ]
      },
      {
        "text": "¿Qué modelo de comunicación indirecta implica conocer los identificadores de los destinatarios del mensaje que enviamos?",
        "options": [
          { "id": 0, "text": "Comunicación en grupo", "isCorrect": false },
          { "id": 1, "text": "Colas de mensajes", "isCorrect": false },
          { "id": 2, "text": "Ninguno.", "isCorrect": true },
          { "id": 3, "text": "Modelo de memoria distribuida compartida", "isCorrect": false }
        ]
      },
      {
        "text": "Marca la afirmación correcta en relación a los sistemas de propagación de eventos de publicación–subscripción basados en broker:",
        "options": [
          { "id": 0, "text": "Los publicadores no conocen las referencias de los subscriptores.", "isCorrect": true },
          { "id": 1, "text": "Cada publicador es responsable de almacenar las referencias de sus subscriptores.", "isCorrect": false },
          { "id": 2, "text": "Cada subscriptor es responsable de almacenar las referencias de sus publicadores.          ", "isCorrect": false },
          { "id": 3, "text": "Cada pareja publicador-subscriptor es única y está identificada unívocamente.", "isCorrect": false }
        ]
      },
      {
        "text": "¿En qué caso NO es adecuado a priori el uso de un middleware de colas de mensajes distribuidas?",
        "options": [
          { "id": 0, "text": "Emisores y receptores no están activos al mismo tiempo.", "isCorrect": false },
          { "id": 1, "text": " Los receptores se encuentran dispersos en múltiples nodos de la red.", "isCorrect": false },
          { "id": 2, "text": " Los emisores esperan los resultados del cómputo realizado en los receptores.", "isCorrect": true },
          { "id": 3, "text": "Se desea persistencia de los mensajes.", "isCorrect": false }
        ]
      },
      {
        "text": "IceStorm es un sistema de propagación de eventos basado en...",
        "options": [
          { "id": 0, "text": "contenid", "isCorrect": false },
          { "id": 1, "text": "tipo", "isCorrect": false },
          { "id": 2, "text": "canal", "isCorrect": true },
          { "id": 3, "text": "Ninguno de los otros", "isCorrect": false }
        ]
      },
      {
        "text": "La figura de la izquierda representa el diagrama de eventos de un SD formado por tres procesos. Para cada evento se muestra su estado local, asumiendo que el valor inicial es 0 para todos los procesos. El diagrama de la derecha (que contiene un error) es el diagrama de transición de estados globales correspondiente: ¿Cuál sería el valor del reloj lógico vectorial del tercer evento de P2?",
        "questionURL": "https://raw.githubusercontent.com/Iam-Jorge/Quiz/master/public/images/Ex-Jun-23.JPG",
        "options": [
          { "id": 0, "text": "(1,3,1) ", "isCorrect": false },
          { "id": 1, "text": "(2,3,1) ", "isCorrect": false },
          { "id": 2, "text": "(0,3,0)", "isCorrect": true },
          { "id": 3, "text": "(1,2,1)", "isCorrect": false }
        ]
      },
      {
        "text": "¿Cuántos eventos han ocurrido en el estado global S031?",
        "questionURL": "https://raw.githubusercontent.com/Iam-Jorge/Quiz/master/public/images/Ex-Jun-23.JPG",
        "options": [
          { "id": 0, "text": "2", "isCorrect": false },
          { "id": 1, "text": "4", "isCorrect": true },
          { "id": 2, "text": "5", "isCorrect": false },
          { "id": 3, "text": "No es determinista", "isCorrect": false }
        ]
      },
      {
        "text": "¿Cuáles son los valores de a, b y c después de ocurrir el segundo evento de P3?",
        "questionURL": "https://raw.githubusercontent.com/Iam-Jorge/Quiz/master/public/images/Ex-Jun-23.JPG",
        "options": [
          { "id": 0, "text": "a=3, b=3, c=2", "isCorrect": false },
          { "id": 1, "text": "a=3, b=2, c=2", "isCorrect": false },
          { "id": 2, "text": "a=3, b=indeterminado, c=2", "isCorrect": true },
          { "id": 3, "text": "No es determinista", "isCorrect": false }
        ]
      },
      {
        "text": " Dada la función f = a + b == c + 1, ¿cuáles serían los resultados de evaluar los predicados «posiblemente(f)» y«definitivamente(f)»?",
        "options": [
          { "id": 0, "text": "false, false", "isCorrect": false },
          { "id": 1, "text": "false, true", "isCorrect": false },
          { "id": 2, "text": "true, false", "isCorrect": false },
          { "id": 3, "text": "true, true", "isCorrect": true }
        ]
      },
      {
        "text": " Un diagrama de estados globales consistentes tiene dos propiedades fundamentales ¿cuál de las siguientes NO es una de ellas?",
        "options": [
          { "id": 0, "text": "En un estado, haber almacenado recepción de mensajes, pero no su envío.", "isCorrect": true },
          { "id": 1, "text": " El estado almacenado es alcanzable desde el estado inicial.", "isCorrect": false },
          { "id": 2, "text": " El estado final es alcanzable desde el estado almacenado.", "isCorrect": false }
        ]
      },{
        "text": " Sea un cliente y un servidor ejecutando el algoritmo de Cristian, tras el proceso de sincronización, el cliente actualiza a Tc=12:00:00, en ese mismo instante, observamos el tiempo del servidor y es Ts=12:00:01, ¿Qué hora original tenía el cliente antes del proceso de sincronización?",
        "options": [
          { "id": 0, "text": "12:00:01", "isCorrect": false },
          { "id": 1, "text": "12:00:02", "isCorrect": false },
          { "id": 2, "text": "12:00:00:05", "isCorrect": false },
          { "id": 3, "text": "Ninguna respuesta es válida", "isCorrect": true }
        ]
      },{
        "text": "Disponemos de un sistema distribuido formado por 10 procesos (P1-P10). P5 está actuando como servidor central para exclusión mutua, pero debido a un fallo del nodo, el proceso termina inesperadamente. ¿Qué opción considera más adecuada para decidir qué proceso debe desempeñar ahora esa función teniendo en cuenta que todos ellos tienen la capacidad de hacerlo?",
        "options": [
          { "id": 0, "text": "El siguiente: P6", "isCorrect": false },
          { "id": 1, "text": "El anterior: P7.", "isCorrect": false },
          { "id": 2, "text": "Deberían ejecutar un algoritmo de elección.", "isCorrect": true },
          { "id": 3, "text": " Deberían esperar a que P5 esté activo de nuevo", "isCorrect": false }
        ]
      },
      {
        "text": "¿Qué implica «multicast causal»?",
        "options": [
          { "id": 0, "text": "Los mensajes enviados por un proceso llegarán a en el mismo orden que fueron enviados.", "isCorrect": false },
          { "id": 1, "text": "Si existe una relación causal entre el envío de dos mensajes multicast, su recepción respeta ese mismo orden.", "isCorrect": true },
          { "id": 2, "text": "Todos los mensajes recibidos por un proceso del grupo son confirmados individualmente al emisor.", "isCorrect": false },
          { "id": 3, "text": "Todos las la entregas correspondiente a un mismo envío llegarán a la vez a todos los procesos del grupo.", "isCorrect": false }
        ]
      },
      {
        "text": "Si ejecutamos el algoritmo de Ricart y Agrawala en una red que soporta multicast, la cantidad de mensajes para acceder a la sección crítica...",
        "options": [
          { "id": 0, "text": "aumenta", "isCorrect": false },
          { "id": 1, "text": "disminuye", "isCorrect": true },
          { "id": 2, "text": "no varía", "isCorrect": false },
          { "id": 3, "text": "depende de qué proceso ostenta el testigo", "isCorrect": false }
        ]
      },
      {
        "text": " ¿A qué se refiere la propiedad «liveness» cuando se aplica a un algoritmo de exclusión mutua distribuida?",
        "options": [
          { "id": 0, "text": "Asegura que no habrá inanición o deadlock.", "isCorrect": true },
          { "id": 1, "text": "Asegura que solo un proceso podrán entrar en la CS.", "isCorrect": false },
          { "id": 2, "text": "Asegura que los procesos obtendrán acceso a la CS en el mismo orden que lo pidieron.", "isCorrect": false },
          { "id": 3, "text": "Asegura que la CS fue liberada antes de otorgar permiso a otro proceso.", "isCorrect": false }
        ]
      },
      {
        "text": "El algoritmo de Ricart and Agrawala se basa en:",
        "options": [
          { "id": 0, "text": "Relojes lógicos y soporte multicast.", "isCorrect": true },
          { "id": 1, "text": "La necesidad de elegir un nuevo coordinador.", "isCorrect": false },
          { "id": 2, "text": "El paso continuo de un testigo.", "isCorrect": false },
          { "id": 3, "text": "La creación de subconjuntos de voto.", "isCorrect": false }
        ]
      },
      {
        "text": "En el contexto de la replicación ¿a qué nos referimos con «particiones de red»?",
        "options": [
          { "id": 0, "text": "Situaciones en que grupo de una o más réplicas pierden conectividad con el resto.", "isCorrect": true },
          { "id": 1, "text": "Al modo en que se organiza el espacio de almacenamiento local dentro de cada réplica.", "isCorrect": false },
          { "id": 2, "text": "Agrupaciones arbitarias de las réplicas para ofrecer mejor redundancia.", "isCorrect": false },
          { "id": 3, "text": "Es solo una forma de referirse a las subredes que forman la red de nodos.", "isCorrect": false }
        ]
      },
      {
        "text": " ¿Cuál de las siguientes no se encuadra en el concepto de «replicación»?",
        "options": [
          { "id": 0, "text": "Múltiples nodos con servidores que mantienen de forma consistente copias de los mismos datos.", "isCorrect": false },
          { "id": 1, "text": " Los servidores que gestionan los datos replicados están conectados mediante una red.", "isCorrect": false },
          { "id": 2, "text": " Idealemente, el cliente debería ser plenamente consciente con qué servidor está contactando.", "isCorrect": true },
          { "id": 3, "text": "Los nodos replicados pueden ofrecer un servicio en lugar de datos.", "isCorrect": false }
        ]
      },
      {
        "text": " ¿Cuál de las siguientes estrategias de replicación ofrece mayor consistencia?",
        "options": [
          { "id": 0, "text": "Replicación asíncrona", "isCorrect": false },
          { "id": 1, "text": "Consistencia eventual", "isCorrect": false },
          { "id": 2, "text": "Basados en transacciones", "isCorrect": true },
          { "id": 3, "text": "Ordenación débil", "isCorrect": false }
        ]
      }
    ]
  },
  {
    "examName": "Ex-Ene-23",
    "questions": [
      {
        "text": "¿Con qué mecanismo proporcionado por ZeroC Ice está relacionada la técnica de procesamiento «working queue» habitualen los middlewares de colas de mensajes distribuidas?",
        "options": [
          { "id": 0, "text": "Batched invocations", "isCorrect": false },
          { "id": 1, "text": "Asynchronous Method Dispatch", "isCorrect": true },
          { "id": 2, "text": "Asynchronous Method Invocation", "isCorrect": false },
          { "id": 3, "text": "No hay un ningún mencanismo relacionado", "isCorrect": false }
        ]
      },
      {
        "text": "¿Cuál de los siguientes medios de comunicación podríamos considerar que se encuentra desacoplado en espacio, pero acoplado en tiempo?",
        "options": [
          { "id": 0, "text": "RMI", "isCorrect": false },
          { "id": 1, "text": "MQTT", "isCorrect": false },
          { "id": 2, "text": "IP multicast", "isCorrect": true },
          { "id": 3, "text": "Ninguno cumple lo indicado", "isCorrect": false }
        ]
      },
      {
        "text": "¿Qué caracteriza al modelo de suscripción «topic based» en un sistema de publicación-suscripción?",
        "options": [
          { "id": 0, "text": "Depende de la clase (tipo) de los mensajes.", "isCorrect": false },
          { "id": 1, "text": "El «topic» aparece como un campo de los mensajes.", "isCorrect": true },
          { "id": 2, "text": "El «topic» es un nombre de una lista disponible en el broker.", "isCorrect": false },
          { "id": 3, "text": "La suscripción indica el rango de valores en los que está interesado.", "isCorrect": false }
        ]
      },
      {
        "text": "En un sistema de publicación-suscripción ¿Cuál es el principal inconveniente de un broker centralizado respecto a uno descentralizado?",
        "options": [
          { "id": 0, "text": "Poca escalabiliad.", "isCorrect": true },
          { "id": 1, "text": "Su implementación es más compleja.", "isCorrect": false },
          { "id": 2, "text": "Dificultad para garantizar propiedades extremo a extremo, como seguridad.", "isCorrect": false },
          { "id": 3, "text": "No implica inconvenientes adicionales.", "isCorrect": false }
        ]
      },
      {
        "text": " Con la configuración más básica, en las colas de mensajes distribuidas cuando se envía un mensaje a una cola en la que hay varios suscriptores ¿cuántos de ellos lo reciben?",
        "options": [
          { "id": 0, "text": "ninguno", "isCorrect": false },
          { "id": 1, "text": "1", "isCorrect": true },
          { "id": 2, "text": "todos", "isCorrect": false },
          { "id": 3, "text": "Aquellos que no han recibido ningún mensaje previo", "isCorrect": false }
        ]
      },
      {
        "text": "La figura de la izquierda representa el diagrama de eventos de un SD formado por tres procesos. Para cada evento se muestra su estado local, asumiendo que el valor inicial es 0 para todos los procesos. El diagrama de la derecha (que contiene un error) es el diagrama de transición de estados globales correspondiente: ¿Cuál sería el valor del reloj lógico vectorial del segundo evento de P3?",
        "questionURL": "https://raw.githubusercontent.com/Iam-Jorge/Quiz/master/public/images/Ex-Ene-23-1.JPG",
        "options": [
          { "id": 0, "text": "(3,2,2) ", "isCorrect": true },
          { "id": 1, "text": "(3,1,2)", "isCorrect": false },
          { "id": 2, "text": "(0,3,1)", "isCorrect": false },
          { "id": 3, "text": " (0,1,2)", "isCorrect": false }
        ]
      },
      {
        "text": "¿Cuántos eventos han ocurrido en el estado global S221?",
        "questionURL": "https://raw.githubusercontent.com/Iam-Jorge/Quiz/master/public/images/Ex-Ene-23-1.JPG",
        "options": [
          { "id": 0, "text": "2", "isCorrect": false },
          { "id": 1, "text": "4", "isCorrect": false },
          { "id": 2, "text": "5", "isCorrect": true },
          { "id": 3, "text": "No es determinista", "isCorrect": false }
        ]
      },
      {
        "text": "¿Cuáles son los valores de a, b y c después de ocurrir el segundo evento de P1?",
        "questionURL": "https://raw.githubusercontent.com/Iam-Jorge/Quiz/master/public/images/Ex-Ene-23-1.JPG",
        "options": [
          { "id": 0, "text": "a=2, b=2, c=1", "isCorrect": false },
          { "id": 1, "text": " a=2, b=3, c=1", "isCorrect": false },
          { "id": 2, "text": "a=2, b=2, c=indeterminado", "isCorrect": false },
          { "id": 3, "text": "No es determinista", "isCorrect": true }
        ]
      },
      {
        "text": "Dada la función g = a + c > b, ¿cuáles serían los resultados de evaluar los predicados «posiblemente(g)» y «definitivamente(g)»?",
        "questionURL": "https://raw.githubusercontent.com/Iam-Jorge/Quiz/master/public/images/Ex-Ene-23-1.JPG",
        "options": [
          { "id": 0, "text": "false, false", "isCorrect": false },
          { "id": 1, "text": "false, true", "isCorrect": false },
          { "id": 2, "text": "true, false", "isCorrect": false },
          { "id": 3, "text": "true, true", "isCorrect": true }
        ]
      },
      {
        "text": " ¿Qué transición se ha omitido en el diagrama de transición de estados globales?",
        "questionURL": "https://raw.githubusercontent.com/Iam-Jorge/Quiz/master/public/images/Ex-Ene-23-1.JPG",
        "options": [
          { "id": 0, "text": "S030 - S130", "isCorrect": true },
          { "id": 1, "text": "S011 - S111", "isCorrect": false },
          { "id": 2, "text": "S321 - S332", "isCorrect": false },
          { "id": 3, "text": "S130 - S221", "isCorrect": false }
        ]
      },
      {
        "text": "Desde el punto de vista de un sistema distribuido con alta escalabilidad tolerante a fallos, ¿cuál es el aspecto mas débil del algoritmo de exclusión mutua con servidor central?",
        "options": [
          { "id": 0, "text": "El servidor representa un cuello de botella", "isCorrect": true },
          { "id": 1, "text": "Limitaciones en el tamaño de la cola de peticiones.", "isCorrect": false },
          { "id": 2, "text": "En entornos de alta escalabilidad no proporciona liveness.", "isCorrect": false },
          { "id": 3, "text": "En entornos de alta escalabilidad, el alto número de mensajes para entrar y salir de la sección crítica", "isCorrect": false }
        ]
      },
      {
        "text": "Considere un sistema distribuido formado por 5 procesos con PIDs 1, 2, 3, 4 y 5. Si el sistema usa exclusión mutua con servidor central y los procesos 4, 5 y 1 envían un mensaje al coordinador, en ese orden, ¿cuántos mensajes son necesarios para que el proceso 5 logre entrar en la sección crítica?",
        "options": [
          { "id": 0, "text": "5", "isCorrect": false },
          { "id": 1, "text": "8", "isCorrect": false },
          { "id": 2, "text": "9", "isCorrect": false },
          { "id": 3, "text": "No se puede saber", "isCorrect": true }
        ]
      },
      {
        "text": "¿Cuántos mensajes son necesarios si el coordinador priorizase las peticiones de menor a mayor PID, es decir, atiende primero al proceso de menor PID? Suponga que todos los mensajes se reciben al mismo tiempo.",
        "questionURL": "https://raw.githubusercontent.com/Iam-Jorge/Quiz/master/public/images/Ex-Ene-23-2.JPG",
        "options": [
          { "id": 0, "text": "5", "isCorrect": false },
          { "id": 1, "text": "8", "isCorrect": true },
          { "id": 2, "text": "9", "isCorrect": false },
          { "id": 3, "text": "No se puede saber", "isCorrect": false }
        ]
      },
      {
        "text": " Si el sistema utilizase exclusión mutua basada en anillo con testigo, ¿cuántos mensajes deben enviarse para conceder el acceso a la sección crítica al proceso 5? Asuma que el anillo se ordena de menor a mayor PID, que el token se encuentra en el proceso 3 y que el token se mueve en el sentido de menor a mayor PID:",
        "options": [
          { "id": 0, "text": "1", "isCorrect": false },
          { "id": 1, "text": "2", "isCorrect": true },
          { "id": 2, "text": "3", "isCorrect": false },
          { "id": 3, "text": "4", "isCorrect": false }
        ]
      },
      {
        "text": "Siendo N el número de procesos, ¿cuál es el número de mensajes que se utiliza el algoritmo de Ricart y Agrawala para entrar (sin considerar la salida de ningún proceso) en la sección crítica?",
        "options": [
          { "id": 0, "text": "N mensajes", "isCorrect": false },
          { "id": 1, "text": "2*(N-1)", "isCorrect": true },
          { "id": 2, "text": "2 mensajes", "isCorrect": false },
          { "id": 3, "text": "2*sqrt(N)", "isCorrect": false }
        ]
      },
      {
        "text": " Considere un sistema distribuido formado por 4 procesos con IDs 1, 2, 3 y 4. Se quiere seleccionar uno de los procesos como coordinador del sistema utilizando el algoritmo basado en anillo de Chang y Roberts. Asuma que el ID de cada proceso se corresponde con su identificador a efectos de la elección: ¿Cuántos mensajes se enviarán, en el peor caso, para completar la elección?",
        "options": [
          { "id": 0, "text": "7", "isCorrect": false },
          { "id": 1, "text": "8", "isCorrect": false },
          { "id": 2, "text": "15", "isCorrect": false },
          { "id": 3, "text": "11", "isCorrect": true }
        ]
      },
      {
        "text": "En el ejemplo anterior, si se usara el algoritmo de García-Molina y asumiendo que no ocurre ningún error durante el proceso de elección, ¿cuál sería el número de mensajes enviados en total por todos los procesos en el peor de los casos?",
        "questionURL": "https://raw.githubusercontent.com/Iam-Jorge/Quiz/master/public/images/Ex-Ene-23-3.JPG",
        "options": [
          { "id": 0, "text": "Menos de 12", "isCorrect": false },
          { "id": 1, "text": "12", "isCorrect": false },
          { "id": 2, "text": "13", "isCorrect": false },
          { "id": 3, "text": "Más de 13", "isCorrect": true }
        ]
      },
      {
        "text": "¿Qué características del sistema distribuido tiene en consideración el algoritmo de García-Molina no existe en el algoritmo de Chang y Roberts?",
        "options": [
          { "id": 0, "text": "El tamaño del sistema distribuido.", "isCorrect": false },
          { "id": 1, "text": "El identificador de cada proceso es desconocido para los demás procesos.", "isCorrect": false },
          { "id": 2, "text": "Tolerancia a fallos en los procesos.", "isCorrect": true },
          { "id": 3, "text": "Todas las anteriores son correctas.", "isCorrect": false }
        ]
      },
      {
        "text": "¿Cuál de las siguientes no es una característica considerada por el teorema CAP?",
        "options": [
          { "id": 0, "text": "Consistencia de datos", "isCorrect": false },
          { "id": 1, "text": "Disponibilidad del sistema", "isCorrect": false },
          { "id": 2, "text": "Ventana de inconsistencia estricta", "isCorrect": true },
          { "id": 3, "text": "Tolerancia a las particiones de red", "isCorrect": false }
        ]
      },
      {
        "text": " ¿Qué es la «ventana de inconsistencia» (inconsistency window)?",
        "options": [
          { "id": 0, "text": "Es el plazo en el que la réplica permite nuevas operaciones de escritura sin afectar al valor persistente almacenado.", "isCorrect": false },
          { "id": 1, "text": "El plazo que transcurre entre una escritura y el momento es que está garantizado que se puede acceder al último valor.", "isCorrect": true },
          { "id": 2, "text": "El tamaño mínimo del buffer de envío que garantiza que todas las réplicas se podrán actualizar en el tiempo solicitado.", "isCorrect": false },
          { "id": 3, "text": "El conjunto de operaciones de lectura/escritura que puede manejar el gestor de réplicas antes de que se actualice un recurso.", "isCorrect": false }
        ]
      },
      {
        "text": "Escoja la definición más ajustada a protocolo líder/seguidores",
        "options": [
          { "id": 0, "text": "Protocolo para conseguir consistencia débil en el que todos los nodos pueden actuar como líder o seguidor en cada transacción.", "isCorrect": false },
          { "id": 1, "text": "Protocolo para conseguir consistencia fuerte dónde un nodo tiene un rol distinguido del resto.", "isCorrect": false },
          { "id": 2, "text": " Protocolo para conseguir consistencia débil dónde un nodo tiene un rol distinguido del resto.", "isCorrect": true },
          { "id": 3, "text": " Protocolo para conseguir consistencia débil donde los nodos seguidores almacenan una copia parcial del líder", "isCorrect": false }
        ]
      },
      {
        "text": "Para un conjunto de 6 nodos, se define un método de votación (quorum) y usted debe definir el número de copias de lectura (R) y el número de copias de escritura (W) ¿qué números propondría para garantizar la consistencia?",
        "options": [
          { "id": 0, "text": "R=3, W=4", "isCorrect": true },
          { "id": 1, "text": "R=2, W=3", "isCorrect": false },
          { "id": 2, "text": "R=4, W=2", "isCorrect": false },
          { "id": 3, "text": "R=3, W=3", "isCorrect": false }
        ]
      },
      {
        "text": "¿Cómo se consigue normalmente el «balanceo de carga»?",
        "options": [
          { "id": 0, "text": "El sistema redirige las peticiones de los clientes a las distintas réplicas disponibles.", "isCorrect": true },
          { "id": 1, "text": "El cliente reparte equitativamente sus peticiones entre las réplicas conocidas.", "isCorrect": false },
          { "id": 2, "text": "El planificador decide en qué momento ejecutar las peticiones para haya un equilibrio de carga a lo largo del tiempo.", "isCorrect": false },
          { "id": 3, "text": "Ajustando constantemente el porcentaje de uso de las CPUs disponibles para evitar sobrecargas.", "isCorrect": false }
        ]
      }
    ]
  },
  {
    "examName": "Ex-Jun-22",
    "questions": [
      {
        "text": "RabbitMQ usa un modelo de comunicación indirecta del tipo:",
        "options": [
          { "id": 0, "text": "Sistema basado en eventos distribuidos.", "isCorrect": false },
          { "id": 1, "text": "Cola de mensajes.", "isCorrect": true },
          { "id": 2, "text": "Memoria distribuida.", "isCorrect": false },
          { "id": 3, "text": "Comunicación uno a uno.", "isCorrect": false }
        ]
      },
      {
        "text": "Marca la afirmación correcta en relación a los sistemas de propagación de eventos de publicación–subscripción basados en broker:",
        "options": [
          { "id": 0, "text": "Los publicadores no conocen las referencias de los subscriptores.", "isCorrect": true },
          { "id": 1, "text": "Cada publicador es responsable de almacenar las referencias de sus subscriptores.", "isCorrect": false },
          { "id": 2, "text": "Cada subscriptor es responsable de almacenar las referencias de sus publicadores.", "isCorrect": false },
          { "id": 3, "text": "Cada pareja publicador-subscriptor es única y está identificada unívocamente.", "isCorrect": false }
        ]
      },
      {
        "text": "¿Cuál sería la definición más acertada de un sistema de colas de mensajes distribuidas?",
        "options": [
          { "id": 0, "text": "El emisor coloca sus mensajes en una cola genérica el broker los clasifica y responde al emisor.", "isCorrect": false },
          { "id": 1, "text": "Un broker central determina el receptor de cada mensaje de la cola distribuida.", "isCorrect": true },
          { "id": 2, "text": "Varios receptores reciben copias del mismo mensaje.", "isCorrect": false },
          { "id": 3, "text": "No hay diferencias sustanciales con un sistema publicador-subscriptor.", "isCorrect": false }
        ]
      },
      {
        "text": "¿Cuál de los siguientes NO se considera un mecanismo de comunicación indirecta?",
        "options": [
          { "id": 0, "text": "Comunicación de grupos", "isCorrect": false },
          { "id": 1, "text": "Sistemas de propagación de eventos", "isCorrect": false },
          { "id": 2, "text": "Llamada a procedimiento remoto", "isCorrect": true },
          { "id": 3, "text": "Memoria compartida distribuida", "isCorrect": false }
        ]
      },
      {
        "text": "¿Cuál de las siguientes frases define mejor el concepto de 'evento'?",
        "options": [
          { "id": 0, "text": "Difusión de una notificación con un valor asociado.", "isCorrect": true },
          { "id": 1, "text": "Comunicación de datos entre dos objetos distribuidos cualesquiera.", "isCorrect": false },
          { "id": 2, "text": "Ejecución de un fragmento de código remoto que retorna una respuesta síncrona.", "isCorrect": false },
          { "id": 3, "text": "Ejecución de un fragmento de código remoto que retorna una respuesta asíncrona.", "isCorrect": false }
        ]
      },
      {
        "text": "¿Qué trata de acotar el cálculo que se aplica en el algoritmo de Cristian?",
        "options": [
          { "id": 0, "text": "El error causado por un ancho de banda asimético.", "isCorrect": false },
          { "id": 1, "text": "El error causado por la latencia de la red.", "isCorrect": true },
          { "id": 2, "text": "La cantidad de mensajes necesarios para la sincronización de un grupo.", "isCorrect": false },
          { "id": 3, "text": "El número de nodos que forma parte del grupo de réplicas.", "isCorrect": false }
        ]
      },
      {
        "text": "En la ejecución del algoritmo de Cristian el tiempo de respuesta que percibe un computador es de 8 segundos y el servidor envía Ts=10:25:07. ¿Cuál es el tiempo al que podría actualizar su hora el cliente?",
        "options": [
          { "id": 0, "text": "10:25:11", "isCorrect": true },
          { "id": 1, "text": "10:25:15", "isCorrect": false },
          { "id": 2, "text": "09:59:59", "isCorrect": false },
          { "id": 3, "text": "Habría que conocer la hora del cliente.", "isCorrect": false }
        ]
      },
      {
        "text": "En la ejecución del algoritmo de Cristian el tiempo de respuesta que percibe un computador es de 8 segundos y el servidor envía Ts=10:25:07. ¿Cuál es el tiempo al que podría actualizar su hora el cliente?",
        "options": [
          { "id": 0, "text": "10:25:11", "isCorrect": true },
          { "id": 1, "text": "10:25:15", "isCorrect": false },
          { "id": 2, "text": "09:59:59", "isCorrect": false },
          { "id": 3, "text": "Habría que conocer la hora del cliente.", "isCorrect": false }
        ]
      },
      {
        "text": "¿Cuál es una interpretación correcta del concepto de 'causalidad potencial'?",
        "options": [
          { "id": 0, "text": "Si un evento es un efecto su causa le precede en la historia de eventos.", "isCorrect": true },
          { "id": 1, "text": "Si un evento tiene la capacidad de causar otro deberá considerarse posterior.", "isCorrect": false },
          { "id": 2, "text": "Dos eventos en distintos nodos nunca tienen relación de orden.", "isCorrect": false },
          { "id": 3, "text": "Define ambos componentes de los relojes lógicos de orden total.", "isCorrect": false }
        ]
      },
      {
        "text": "¿Por qué la detección de terminación de un algoritmo distribuido requiere determinar el estado global?",
        "options": [
          { "id": 0, "text": "Los procesos involucrados podrían estar des-sincronizados.", "isCorrect": false },
          { "id": 1, "text": "No se requiere cuando el algoritmo distribuido es asíncrono.", "isCorrect": false },
          { "id": 2, "text": "Una invocación en tránsito podría implicar que el algoritmo continúa.", "isCorrect": true },
          { "id": 3, "text": "Es necesario determinar el orden causal de todos los mensajes involucrados.", "isCorrect": false }
        ]
      },
      {
        "text": "Marca la afirmación FALSA en relación a los relojes software:",
        "options": [
          { "id": 0, "text": "Su valor se determina a partir de un reloj lógico.", "isCorrect": true },
          { "id": 1, "text": "Su valor se obtiene a partir de un dispositivo hardware local.", "isCorrect": false },
          { "id": 2, "text": "Dos relojes software sin relación pueden tener el mismo valor.", "isCorrect": false },
          { "id": 3, "text": "Se aplican procedimientos específicos para asegurar que no se producen saltos.", "isCorrect": false }
        ]
      },
      {
        "text": "Un sistema con 18 nodos se configura mediante una red de comunicaciones por satélite mediante un contrato de pago por uso (10 euros por MB) a continuación se configura un algoritmo de exclusión mutua para controlar el acceso a una sección crítica. Durante el primer mes de funcionamiento ningún nodo accede a la sección crítica ¿Qué algoritmo implicaría un coste mayor?",
        "options": [
          { "id": 0, "text": "Anillo", "isCorrect": true },
          { "id": 1, "text": "Servidor Central", "isCorrect": false },
          { "id": 2, "text": "Ricart Agrawala", "isCorrect": false },
          { "id": 3, "text": "Si no hay acceso a la sección crítica todos los algoritmos habrían tenido el mismo coste.", "isCorrect": false }
        ]
      },
      {
        "text": "En un problema de exclusión mutua centralizada, necesita implementar un acceso por orden de petición en el acceso a la sección crítica ¿Qué algoritmo de los siguientes garantiza el orden?",
        "options": [
          { "id": 0, "text": "Servidor central", "isCorrect": false },
          { "id": 1, "text": "Anillo con testigo", "isCorrect": false },
          { "id": 2, "text": "Ricart y Agrawala", "isCorrect": true },
          { "id": 3, "text": "Todos los algoritmos garantizan el orden", "isCorrect": false }
        ]
      },
      {
        "text": "Determine el tipo de problema que le ayuda a resolver el algoritmo de anillo:",
        "options": [
          { "id": 0, "text": "Consenso", "isCorrect": false },
          { "id": 1, "text": "Multidifusión", "isCorrect": false },
          { "id": 2, "text": "Consistencia interactiva", "isCorrect": false },
          { "id": 3, "text": "Depende, hay dos algoritmos «de anillo»: uno de exclusión mutua y otro para elección de coordinador", "isCorrect": true }
        ]
      },
      {
        "text": " Construir un sistema que emplea multidifusión sobre el protocolo IP, implica la utilización de:",
        "options": [
          { "id": 0, "text": "SNMP", "isCorrect": false },
          { "id": 1, "text": "TCP", "isCorrect": false },
          { "id": 2, "text": "UDP", "isCorrect": true },
          { "id": 3, "text": "RPC", "isCorrect": false }
        ]
      },
      {
        "text": " En un sistema distribuido con 4 procesos y un recurso compartido R, ningún proceso quiere acceso a R en el instante 0. En el instante 1, el proceso P1 solicita acceso a R. En cuanto a número de mensajes ¿cuál de los siguientes algoritmos es más eficiente para conseguir la exclusión mutua en ausencia de fallos?",
        "options": [
          { "id": 0, "text": "Servidor Central", "isCorrect": true },
          { "id": 1, "text": "Anillo (formado por P2->P3->P4->P1->P2 y el token en P3)", "isCorrect": false },
          { "id": 2, "text": "Ricart y Agrawala (con soporte multicast real)", "isCorrect": false },
          { "id": 3, "text": "García Molina (con soporte multicast real)", "isCorrect": false }
        ]
      },
      {
        "text": "¿Cuál es el comportamiento ideal que persigue la replicación?",
        "options": [
          { "id": 0, "text": "Mantener varias copias idénticas de un recurso o servicio en varios nodos.", "isCorrect": true },
          { "id": 1, "text": "Llevar un registro detallado de los accesos concurrentes a un mismo recurso.", "isCorrect": false },
          { "id": 2, "text": "Acotar el tiempo de acceso a las copias secundarias de un servicio para evitar inanición.", "isCorrect": false },
          { "id": 3, "text": "Impedir el acceso concurrente de varios clientes a un recurso compartido para así evitar inconsistencias", "isCorrect": false }
        ]
      },
      {
        "text": " ¿Por qué decimos que la replicación reduce la latencia?",
        "options": [
          { "id": 0, "text": "No es cierto. La latencia crece linealmente con el número de réplicas.", "isCorrect": false },
          { "id": 1, "text": "El tiempo de sincronización de las réplicas está acotado y converge con el tiempo.", "isCorrect": false },
          { "id": 2, "text": "Si las réplicas se distribuyen geográficamente, la latencia media desde los clientes se reduce", "isCorrect": true },
          { "id": 3, "text": "El balanceador de carga ofrece al cliente un acceso prioritario en función de la carga de los nodos.", "isCorrect": false }
        ]
      },
      {
        "text": "¿Cuál de las siguientes no es una característica considerada por el teorema CAP?",
        "options": [
          { "id": 0, "text": "Consistencia de datos", "isCorrect": false },
          { "id": 1, "text": "Disponibilidad del sistema", "isCorrect": false },
          { "id": 2, "text": "Ventana de inconsistencia estricta", "isCorrect": true },
          { "id": 3, "text": "Tolerancia a las particiones de red", "isCorrect": false }
        ]
      },
      {
        "text": "¿Qué dice el modelo de «consistencia eventual»?",
        "options": [
          { "id": 0, "text": "El programador es responsable de actualizar las copias en base a un modelo líder-seguidores", "isCorrect": false },
          { "id": 1, "text": "Todas las réplicas deben ser sincronizadas inmediatamente después de cualquier acceso a una de las réplicas.", "isCorrect": false },
          { "id": 2, "text": "Si no se hacen escrituras nuevas sobre un recurso dado, todos los accesos devolverán eventualmente el último valor escrito.", "isCorrect": true },
          { "id": 3, "text": " Requiere de un protocolo de transacción distribuidas para garantizar la coherencia entre réplicas, especialmente ante particiones en la red.", "isCorrect": false }
        ]
      },
      {
        "text": "¿Qué es la «ventana de inconsistencia» (inconsistency window)?",
        "options": [
          { "id": 0, "text": "Es el plazo en el que la réplica permite nuevas operaciones de escritura sin afectar al valor persistente almacenado.", "isCorrect": false },
          { "id": 1, "text": "El plazo que transcurre entre una escritura y el momento es que está garantizado que se puede acceder al último valor.", "isCorrect": true },
          { "id": 2, "text": "El tamaño mínimo del buffer de envío que garantiza que todas las réplicas se podrán actualizar en el tiempo solicitado", "isCorrect": false },
          { "id": 3, "text": "El conjunto de operaciones de lectura/escritura que puede manejar el gestor de réplicas antes de que se actualice un recurso.", "isCorrect": false }
        ]
      }
    ]
  },
  {
    "examName": "Otros examenes",
    "questions": [
      {
        "text": "Prueba imagen",
        "questionURL": "https://raw.githubusercontent.com/Iam-Jorge/Quiz/master/public/images/EX1Q1.JPG",
        "options": [
          { "id": 0, "text": "a", "isCorrect": false },
          { "id": 1, "text": "b", "isCorrect": false },
          { "id": 2, "text": "c", "isCorrect": false },
          { "id": 3, "text": "d", "isCorrect": true }
        ]
      },
      {
        "text": "",
        "options": [
          { "id": 0, "text": "", "isCorrect": false },
          { "id": 1, "text": "", "isCorrect": false },
          { "id": 2, "text": "", "isCorrect": false },
          { "id": 3, "text": "", "isCorrect": false }
        ]
      }
    ]
  }
]
